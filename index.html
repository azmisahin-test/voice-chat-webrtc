<!DOCTYPE html>
<html>

<head>
    <title>Voice Chat</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js').then((registration) => {
                console.log('Service Worker registered with scope:', registration.scope);
            }).catch((error) => {
                console.error('Service Worker registration failed:', error);
            });
        }
    </script>
</head>

<body>
    <h1>Voice Chat</h1>
    <audio id="remoteAudio" autoplay></audio>
    <button id="callButton">Start a Conversation</button>
    <p id="status">Status: Disconnected</p>
    <p id="userCount">Users Connected: 0</p>
    <p id="version">Version: <span id="versionNumber"></span></p>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
        import { getDatabase, ref, push, onChildAdded, set, remove, onValue } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDhgqq7aq0j60NhGRDQGkgnvC1uuyMorVU",
            authDomain: "voice-chat-797eb.firebaseapp.com",
            projectId: "voice-chat-797eb",
            databaseURL: "https://voice-chat-797eb-default-rtdb.firebaseio.com/",
            storageBucket: "voice-chat-797eb.appspot.com",
            messagingSenderId: "815348752880",
            appId: "1:815348752880:web:a9e7243ea63e419c7dfd35",
            measurementId: "G-GBT9F23WEL"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        const callButton = document.getElementById("callButton");
        const remoteAudio = document.getElementById("remoteAudio");
        const statusElement = document.getElementById('status');
        const userCountElement = document.getElementById('userCount');
        const versionNumber = document.getElementById("versionNumber");
        let localStream;
        let peerConnection;
        let isCaller = false;
        let offerRef;
        let answerRef;

        const VERSION = "1.0.0";
        versionNumber.textContent = VERSION;

        const servers = {
            iceServers: [
                {
                    urls: "stun:stun.l.google.com:19302",
                },
            ],
        };

        const handleIceCandidateEvent = async (event) => {
            if (event.candidate) {
                console.log('New ICE candidate:', event.candidate.toJSON());
                push(ref(database, 'candidates'), event.candidate.toJSON());
            }
        };

        const handleTrackEvent = (event) => {
            console.log('Received remote stream');
            remoteAudio.srcObject = event.streams[0];
        };

        const addIceCandidates = (peerConnection) => {
            onChildAdded(ref(database, 'candidates'), async (snapshot) => {
                const candidate = new RTCIceCandidate(snapshot.val());
                if (peerConnection.remoteDescription) {
                    console.log('Adding ICE candidate');
                    await peerConnection.addIceCandidate(candidate);
                }
            });
        };

        const updateStatus = (status) => {
            statusElement.textContent = 'Status: ' + status;
        };

        const updateUserCount = (count) => {
            userCountElement.textContent = 'Users Connected: ' + count;
        };

        const handleUserConnection = () => {
            const userRef = ref(database, 'users/' + userId);

            // Firebase Realtime Database'de veriyi set etme
            userRef.set(true)
                .then(() => updateStatus('Connected'))
                .catch(error => updateStatus('Error connecting: ' + error.message));

            // Kullanıcı bağlantısı kesildiğinde veriyi kaldırma
            userRef.onDisconnect().remove()
                .catch(error => console.error('Failed to remove user on disconnect:', error));

            // Bağlı kullanıcı sayısını güncelleme
            onValue(ref(database, 'users'), (snapshot) => {
                const users = snapshot.val();
                const userCount = users ? Object.keys(users).length : 0;
                updateUserCount(userCount);
            });
        };


        const userId = 'user_' + Math.random().toString(36).substring(2, 15);
        handleUserConnection();

        callButton.onclick = async () => {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                peerConnection = new RTCPeerConnection(servers);

                peerConnection.onicecandidate = handleIceCandidateEvent;
                peerConnection.ontrack = handleTrackEvent;

                localStream.getTracks().forEach((track) => {
                    peerConnection.addTrack(track, localStream);
                });

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                offerRef = push(ref(database, 'offers'));
                await set(offerRef, { sdp: offer.sdp, type: offer.type });

                isCaller = true;

                window.addEventListener('beforeunload', () => {
                    if (isCaller && offerRef) {
                        remove(offerRef).catch(error => console.error('Failed to remove offer:', error));
                    }
                    remove(ref(database, 'candidates')).catch(error => console.error('Failed to remove candidates:', error));
                    remove(ref(database, 'users/' + userId)).catch(error => console.error('Failed to remove user on unload:', error));
                });

                onChildAdded(ref(database, 'answers'), async (snapshot) => {
                    const answer = snapshot.val();
                    if (answer && !peerConnection.currentRemoteDescription) {
                        console.log('Setting remote description with answer');
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    }
                });

                addIceCandidates(peerConnection);
            } catch (error) {
                console.error('Error starting call:', error);
            }
        };

        onChildAdded(ref(database, 'offers'), async (snapshot) => {
            const offer = snapshot.val();
            if (!isCaller && offer) {
                try {
                    peerConnection = new RTCPeerConnection(servers);
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                    peerConnection.onicecandidate = handleIceCandidateEvent;
                    peerConnection.ontrack = handleTrackEvent;

                    localStream.getTracks().forEach((track) => {
                        peerConnection.addTrack(track, localStream);
                    });

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    answerRef = push(ref(database, 'answers'));
                    await set(answerRef, { sdp: answer.sdp, type: answer.type });

                    addIceCandidates(peerConnection);
                } catch (error) {
                    console.error('Error setting up offer response:', error);
                }
            }
        });

        window.addEventListener('beforeunload', () => {
            remove(ref(database, 'candidates')).catch(error => console.error('Failed to remove candidates on unload:', error));
        });
    </script>
</body>

</html>